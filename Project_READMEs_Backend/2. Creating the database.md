## Creating the database

We'll start from the basic flask code from earlier, along with the imported libraries:

```
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow
import os

app = Flask(__name__)

@app.route('/')

if __name__ == '__main__':
    app.run(debug=True)
```

But first, we need to save our future database by integrating it into the system. We basically want to tell Flask where our database is gonna be stored, and then we're going to name the DB and join the basedir and the app name (sqlite). Then we've created two objects.

```
basedir = os.path.abspath(os.path.dirname(__file__))
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'app.sqlite')
db = SQLAlchemy(app)
ma = Marshmallow(app)
```

Now we can create the pseudo-database. We'll first create the schema, which is the container for all our tables. In termns of pure SQL code, we have this:

```
CREATE SCHEMA `capstone_db`

CREATE TABLE `capstone_db`.`users` (
  `user_id` INT NOT NULL AUTO_INCREMENT,
  `user_email` VARCHAR(45) NOT NULL,
  `user_password` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`user_id`),
  UNIQUE INDEX `user_id_UNIQUE` (`user_id` ASC) VISIBLE,
  UNIQUE INDEX `user_email_UNIQUE` (`user_email` ASC) VISIBLE);

  CREATE TABLE `capstone_db`.`items` (
  `item_id` INT NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`item_id`),
  UNIQUE INDEX `item_id_UNIQUE` (`item_id` ASC) VISIBLE);
```

Now, we're going to create our first table with SQL Alchemy, along its instances:

```
class user(db.Model):
    user_id = db.Column(db.Integer, autoincrement=True, primary_key=True)
    user_email = db.Column(db.String(50), unique=True)
    user_password = db.Column(db.String(20), unique=False)

    def __init__(self, user_email, user_password):
        self.user_email = user_email
        self.user_password = user_password
```

Now we're going to create a schema and its instances as well. Notice that we have an instance for working with multiple users.

```
class userSchema(ma.Schema):
    class Meta:
        fields = ("user_email", "user_password")

user_schema = userSchema()
users_schema = userSchema(many=True)
```

> We're instantiating the database. The db object is a call to ``db = SQLAlchemy(app)``.

Now we'll create our second table, the item table that will (later) allow the API to get those items.

```
class item(db.Model):
    item_id = db.Column(db.Integer, autoincrement= True, primary_key=True)
    item_title = db.Column(db.String(100), unique=False)
    item_content = db.Column(db.UnicodeText, unique=False)
    item_user_id = db.Column(db.Integer, ForeignKey(user.user_id), nullable=False)

    def __init__(self, item_title, item_content, item_user_id):
        self.item_title = item_title
        self.item_content = item_content
        self.item_user_id = item_user_id

class itemSchema(ma.Schema):
    class Meta:
        fields = ("item_title", "item_content", "item_user_id")

item_schema = itemSchema()
items_schema = itemSchema(many=True)
```

> Note that the data type of the item_content is not a string, but an un-lengthed unicode text type because we don't know beforehand the length of the items' content.


Now, we'll type this in the terminal (make sure the pipenv shell is running, or just type ``python``):

```
from app import app, db
with app.app_context().push():
    db.create_all()
```

This will create a pycache file. Now we're ready to create the API endpoints.