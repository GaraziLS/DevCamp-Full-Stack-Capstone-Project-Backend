## Creating the API endpoints

Still on the **app.py** file, we'll create our API endpoints there. We'll have the following endpoints:

<!-- # TODO API routes
* POST 
    /create -> Creates a new item
    /login -> Logs a user in
    /signup -> Registers a user

* GET
    /tables -> Gets all the items
    /tables/{table_id} -> Gets a single item
    /users/{user_id} -> Gets a single user
    /tables/users/{user_id} -> Gets all the generators of a given user

* PUT/PATCH
    /tables/{item_id} -> Updates an item


* DELETE
    /tables/{item_id} -> Deletes an item
    /users/{user_id} -> Deletes a user account
 -->

First of all, we'll import two more libraries from flask:

```
from flask import Flask, request, jsonify
```

Now we can start with our endpoints.

 ## Route to create a new item

```
@app.route("/create", methods=['POST'])
def add_item():
    title = request.json["item_title"]
    content = request.json["item_content"]
    item_user_id = request.json["item_user_id"]
```

So we're calling the app itself and passing the route and the method it's going to take. Then, we're doing a title and content request and we're storing each one in a variable. We're passing those variables to our table (to the class), and we're then storing all of that inside another variable. 

```
@app.route("/create", methods=['POST'])
def add_item():
    title = request.json["item_title"]
    content = request.json["item_content"]
    item_user_id = request.json["item_user_id"]

    new_item_instance = Item(title, content, item_user_id)
```

We'll use this last variable (new_item_instance) to connect with the database itself, and will then commit the changes. 

```
new_item = item(title, content)
db.session.add(new_item)
db.session.commit()
```

Now we'll return the table itself to query the new_item_instance in, along with the primary key of the table we're querying. We'll store that in a variable and then, we'll be returning the schema, parsing it with json, and returning the last variable we created:

```
item = Item.query.get(new_item.item_id)

return item_schema.jsonify(item)
```

So the entire route goes like this:

```
@app.route("/create", methods=['POST'])
def add_item():
    title = request.json["title"]
    content = request.json["content"]

    new_item = item(title, content)

    db.session.add(new_item)
    db.session.commit()

    item = Item.query.get(new_item.item_id)

    return item_schema.jsonify(item)
```

We can now activate the virtual environment and ``python app.py`` to go to postman and test the requests.

If we post this in the body after selecting a post request with a localhost:5000/create:

```
{
    "item_title": "A title",
    "item_content": "Some content",
    "item_user_id": 1
}
```

The object itself gets returned, so it works.

Now we'll repeat the process for the other endpoints.

## Route to log a user in 

```
@app.route("/auth/login", methods=['POST'])
def login_user():
    user_name = request.json["user_name"]
    user_email = request.json["user_email"]
    user_password = request.json["user_password"]

    logged_user_instance = User(user_name, user_email, user_password)

    db.session.add(logged_user_instance)
    db.session.commit()

    user = User.query.get(logged_user_instance.user_id) 

    return user_schema.jsonify(user)
```

<!-- # TODO: Create a hyperlink that goes to the user's profile when they're logged in -->

## Route to sign up

```
@app.route("/auth/signup", methods=['POST'])
def login_user():
    user_name = request.json["user_name"]
    user_email = request.json["user_email"]
    user_password = request.json["user_password"]

    registered_user_instance = User(user_name, user_email, user_password)

    db.session.add(registered_user_instance)
    db.session.commit()

    user = User.query.get(logged_user_instance.user_id) 

    return user_schema.jsonify(user)
```

## Route to get all items

GET requests are a little bit different. We'll start as usual, but will make a variable to store the query, like this:

```
@app.route("/tables", methods=['GET'])
def get_items():
    all_items = Item.query.all
```

> Note that we're calling the class here.

Now we're going to create a result variable where we'll store the multiple guides' schema, and pass the all_items (the variable we just created) variable in. We then return the result item in json format:

```
@app.route("/tables", methods=['GET'])
def get_items():
    all_items = Item.query.all
    result = items_schema.dump(all_items)
    return jsonify(result)
```

> When getting items no data must be entered, because the items themselves are returned. If we create these items 

```
    {
         "item_title": "A title",
        "item_content": "Some content",
        "item_user_id": 1
    },

    {
        "item_title": "Another title",
        "item_content": "Lorem ipsum dolor sit amet",
        "item_user_id": 2
    },

    {
        "item_title": "The Legend of Zelda",
        "item_content": "Power Courage Wisdom",
        "item_user_id": 1
    }
```

and hit send, when we change the method to GET we don't need to write these because they're already in the database, so our items just get returned in the response.

## Route to get a single item or user

To get a single item, we need to pass the item id. We'll start as usual:

```
@app.route("/tables/<id>", methods=['GET'])
def get_item(id):
    single_item = Item.query.get(id)
    return item_schema.jsonify(single_item)
```

```
@app.route("/users/<id>", methods=['GET'])
def get_user(id):
    single_user = User.query.get(id)
    return user_schema.jsonify(single_user)
```

In the route, we're passing the item's id. In the function, we pass the id as well, and then we perform a query and store it inside a variable (don't forget to pass the id). We return the single item schema and pass the variable that stores the query.

Now if we change the url in Postman and pass an id, we'll get a single item.

## Route to update an item

We'll be using the PUT verb now to update an item. We'll pass the id, just like we did the single item endpoint.



